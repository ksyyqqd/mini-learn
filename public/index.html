<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>MiniApp Renderer</title>
    <link rel="stylesheet" href="/app.css">
    <style>
      body { font-family: system-ui, sans-serif; padding: 16px }
      pre { background:#f6f8fa; padding:12px; border-radius:6px }
      button { padding: 8px 16px; margin: 4px; cursor: pointer; }
    </style>
  </head>
  <body>
    <h1>MiniApp Renderer (Browser)</h1>
    <div>Server-Sent Events connected to <code>/events</code></div>
    <h2>Rendered Output</h2>
    <div id="render">(waiting...)</div>

    <h2>Raw Data</h2>
    <pre id="data">(waiting...)</pre>

    <h2>App Console</h2>
    <pre id="app-console">(waiting...)</pre>

    <script>
      const es = new EventSource('/events');
      const renderEl = document.getElementById('render');
      const dataEl = document.getElementById('data');
      
      // 添加全局方法调用函数
      window.callAppMethod = async function(methodName, args = {}) {
        console.log('Calling app method:', methodName, args);
        try {
          const response = await fetch('/api/callMethod', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              methodName: methodName,
              args: args
            })
          });
          
          const result = await response.json();
          if (!response.ok) {
            console.error('Method call failed:', result.error || response.status);
          } else {
            console.log('Method call success:', result);
          }
        } catch (error) {
          console.error('Method call error:', error);
        }
      };
      
      // 动态绑定onclick事件
      function bindEvents() {
        const buttons = document.querySelectorAll('button[onclick]');
        buttons.forEach(button => {
          const onclickAttr = button.getAttribute('onclick');
          if (onclickAttr) {
            // 提取方法名（去除括号和参数）
            const methodName = onclickAttr.replace(/\(.*\)$/, '').trim();
            if (methodName) {
              button.onclick = function(e) {
                e.preventDefault();
                console.log('Button clicked, calling method:', methodName);
                window.callAppMethod(methodName);
              };
            }
          }
        });
      }
      
      es.onmessage = (e) => {
        try {
          const obj = JSON.parse(e.data);
          if (obj.type === 'console') { 
            const c = document.getElementById('app-console');
            const p = obj.payload;
            const text = (p.args || []).map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
            const line = `[${p.level}] ${text}\n`;
            c.textContent = (c.textContent === '(waiting...)' ? '' : c.textContent) + line;
            // 也输出到浏览器开发者控制台
            if (console && console[p.level]) console[p.level].apply(console, p.args || []);
            return;
          }
          if (obj.html) {
            renderEl.innerHTML = obj.html;
            console.log('HTML updated, binding events...');
            // 每次渲染后重新绑定事件
            setTimeout(bindEvents, 10);
          }
          dataEl.textContent = JSON.stringify(obj.data, null, 2);
        } catch (err) {
          dataEl.textContent = e.data;
        }
      };
      es.onerror = () => { dataEl.textContent = '(connection error)'; };
      
      // 初始绑定事件
      setTimeout(bindEvents, 100);
    </script>
  </body>
</html>